// Extract important information from the voxel world space given the map position 
bool extractVoxel(ivec3 mapPos, out Material material){
    material = Material(vec3(1, 0, 0), 0, 0, 0, vec2(0));
    if (mapPos == vec3(0, 0, 0)){
        return true; 
    }
    return false; 
}

// Branchless DDA with help from https://www.shadertoy.com/view/4dX3zl and https://www.shadertoy.com/view/mtyfRV (I know how branched DDA works, but this is more efficient)
bool rayMarch(Ray ray, inout HitRecord record, inout uvec4 state){
    vec3 rayDirSign = sign(ray.direction);
    ivec3 mapPos = ivec3(floor(ray.origin));   
    vec3 deltaDist = abs(vec3(length(ray.direction)) / ray.direction);
    ivec3 rayStep = ivec3(rayDirSign);
    vec3 sideDist = (rayDirSign * (vec3(mapPos) - ray.origin) + (rayDirSign * 0.5 + 0.5)) * deltaDist;
    vec3 mask; Material material;

    for (int i; i < maxRaySteps; i++){
        if (extractVoxel(mapPos, material)){
            record.normalVector = -rayDirSign * mask;
            record.tValues.t = dot(record.normalVector, vec3(mapPos) + max(vec3(0), record.normalVector) - ray.origin) / dot(record.normalVector, ray.direction);

            record.pointHit = rayIntersectPoint(ray, record.tValues.t);    
            isFrontFace(ray, record);

            scatter(material.materialID, material.materialParameter, ray, record, state);  
            record.objectColor = applyTexture(material.color, material.textureID, vec2(0, 0));   

            return true;
        }

        mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

        sideDist += mask * deltaDist;
        mapPos += ivec3(mask) * rayStep;
    }
    return false;
}