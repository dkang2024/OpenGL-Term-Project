// Initialize a default vector
vec3 initDefaultVec(){
    return vec3(0, 0, 0);
}

// Checks whether all elements of a vector are near zero for dealing with floating point inaccuracies
bool nearZero(vec3 v){
    float epsilon = 1e-5;
    return v.x < epsilon && v.y < epsilon && v.z < epsilon;
}

// Generate a random vector on the unit sphere by using the method shown in https://mathworld.wolfram.com/SpherePointPicking.html. 
vec3 randomVectorOnUnitSphere(inout uvec4 state){
    vec3 randVec = initDefaultVec();
    while (length(randVec) < 0.001){
        randVec = vec4(boxMuller(state), boxMuller(state)).xyz;
    }
    return normalize(randVec);
}

// Use Schlick's approximation to get the reflectance. Introduced the math throguh https://raytracing.github.io/books/RayTracingInOneWeekend.html. 
float reflectance(float cosTheta, float etaRatio){
    float r0 = (1 - etaRatio) / (1 + etaRatio);
    r0 = pow(r0, 2);
    return r0 + (1 - r0) * pow(1 - cosTheta, 5);
}