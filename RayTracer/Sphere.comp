// Sphere Structure
struct sphere3{
    vec3 center;
    float radius;
    vec3 color;
};

// Sphere ray intersection helper functions 

// Returns the discriminant given a simplified sphere equation
float simplifiedDiscriminant(float a, float c, float h){
    return pow(h, 2) - a * c;
}

// Returns the quadratic formula given a simplified sphere equation
float simplifiedQuadFormula(float a, float h, float discriminant, float signValue){
    return (h + signValue * pow(discriminant, 0.5)) / a; 
}

// Find the sphere's normal vector (not always made to point against the ray [this will be done in hit record])
vec3 findSphereNormalVector(ray3 ray, float t, vec3 center, float radius){
    return (rayIntersectPoint(ray, t) - center) / radius;
}

// Check if the ray intersects with the sphere using the quadratic formula with math gotten from https://www.cs.colostate.edu/~cs410/yr2016fa/more_progress/cs410_F16_Lecture14.pdf. Automaticall deal with returning the lesser t by taking the negative sign first. 
bool checkSphereIntersection(float a, float h, float discriminant){
    float t = simplifiedQuadFormula(a, h, discriminant, -1);
    if (!(rayMin < t && t < rayMax)){
        t = simplifiedQuadFormula(a, h, discriminant, 1);
        if (!(rayMin < t && t < rayMax)){
            return false; 
        } 
    }
    return true;
}

// Do all of the complete logic to check if a ray intersects with a sphere, including finding the discriminant and other values. The difference between this and checkSphereIntersection is that a, h, discriminant are calculated
bool hitSphere(sphere3 sphere, ray3 ray){
    vec3 rayToSphereCenter = sphere.center - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float h = dot(ray.direction, rayToSphereCenter);
    float c = dot(rayToSphereCenter, rayToSphereCenter) - pow(sphere.radius, 2);
    float discriminant = simplifiedDiscriminant(a, c, h);

    if (discriminant < 0){ // If the discriminant is less than zero, the t values for the intersection are imaginary and does doesn't intersect (don't even check the t for intersection)
        return false;
    }

    return checkSphereIntersection(a, h, discriminant);
}
