// Sphere Structure
struct Sphere{
    vec3 center;
    float radius;
    vec3 color;
    int materialID;
    float materialParameter;
    int textureID;
    vec2 padding;
};

// Sphere ray intersection helper functions 

// Returns the discriminant given a simplified sphere equation
float simplifiedDiscriminant(float a, float c, float h){
    return pow(h, 2) - a * c;
}

// Returns the quadratic formula given a simplified sphere equation
float simplifiedQuadFormula(float a, float h, float discriminant, float signValue){
    return (h + signValue * sqrt(discriminant)) / a; 
}

// Find the sphere's normal vector (not always made to point against the ray [this will be done in hit record])
vec3 findSphereNormalVector(inout HitRecord record, Sphere sphere){
    record.normalVector = (record.pointHit - sphere.center) / sphere.radius;
    return record.normalVector;
}

// Check if the ray intersects with the sphere using the quadratic formula with math gotten from https://www.cs.colostate.edu/~cs410/yr2016fa/more_progress/cs410_F16_Lecture14.pdf. Automatically deal with returning the lesser t by taking the negative sign first. 
bool checkSphereIntersection(float a, float h, float discriminant, Ray ray, inout HitRecord record){
    float t = simplifiedQuadFormula(a, h, discriminant, -1);
    if (outOfBounds(record.tValues, t)){
        t = simplifiedQuadFormula(a, h, discriminant, 1);
        if (outOfBounds(record.tValues, t)){
            return false; 
        } 
    }

    record.tValues.t = t; 
    record.pointHit = rayIntersectPoint(ray, t);
    return true;
}

// Return the sphere's texture coordinates using math from https://en.wikipedia.org/wiki/UV_mapping
vec2 sphereUV(vec3 outVec){
    float u = 0.5 + atan(outVec.z, outVec.x) / (2 * PI);
    float v = 0.5 + asin(outVec.y) / PI;
    return vec2(u, v);
}

// Common sphere intersection code in both hitSphere and hitSphereLight 
void commonSphereCalculations(Sphere sphere, Ray ray, inout float a, inout float h, inout float discriminant){
    vec3 rayToSphereCenter = sphere.center - ray.origin;
    a = dot(ray.direction, ray.direction);
    h = dot(ray.direction, rayToSphereCenter);
    float c = dot(rayToSphereCenter, rayToSphereCenter) - pow(sphere.radius, 2);
    discriminant = simplifiedDiscriminant(a, c, h);
}

// Do all of the complete logic to check if a ray intersects with a sphere, including finding the discriminant and other values. The difference between this and checkSphereIntersection is that a, h, discriminant are calculated
bool hitSphere(Sphere sphere, Ray ray, inout HitRecord record, inout uvec4 state){
    float a;
    float h; 
    float discriminant;

    commonSphereCalculations(sphere, ray, a, h, discriminant);

    if (discriminant < 0){ // If the discriminant is less than zero, the t values for the intersection are imaginary and does doesn't intersect (don't even check the t for intersection for efficiency's sake)
        return false;
    }

    bool didHit = checkSphereIntersection(a, h, discriminant, ray, record);
    if (!didHit){
        return false;
    }

    // Note that the ideas for the hit record and storing the intersection points and variables like this came from https://raytracing.github.io/books/RayTracingInOneWeekend.html#movingcameracodeintoitsownclass. Heavily modified though :).
    vec3 outwardNormalVector = findSphereNormalVector(record, sphere);
    isFrontFace(ray, record);
    scatter(sphere.materialID, sphere.materialParameter, ray, record, state);

    record.objectColor = applyTexture(sphere.color, sphere.textureID, sphereUV(outwardNormalVector));
    
    return true;
}

// Simplified version of the function above to only check whether the ray intersects with the object before the light
bool checkSphereLightIntersection(float a, float h, float discriminant, Ray ray, Interval tInterval){
    float t = simplifiedQuadFormula(a, h, discriminant, -1);
    if (outOfBounds(tInterval, t)){
        t = simplifiedQuadFormula(a, h, discriminant, 1);
        if (outOfBounds(tInterval, t)){
            return false; 
        } 
    }
    return true;
}

// Simplified version of the function above to only check whether hte ray intersects with the object before the light in question for shadow rays
bool hitSphereLight(Sphere sphere, Ray ray, Interval tInterval){
    float a;
    float h; 
    float discriminant;

    commonSphereCalculations(sphere, ray, a, h, discriminant);

    if (discriminant < 0){ // If the discriminant is less than zero, the t values for the intersection are imaginary and does doesn't intersect (don't even check the t for intersection for efficiency's sake)
        return false;
    }

    bool didHit = checkSphereLightIntersection(a, h, discriminant, ray, tInterval);
    if (!didHit){
        return false;
    }

    return true;
}