// Sphere Structure
struct Sphere{
    vec4 center;
    vec4 color;
    float radius;
    int materialID;
    float materialParameter;
    int textureID;
};

// Sphere ray intersection helper functions 

// Returns the discriminant given a simplified sphere equation
float simplifiedDiscriminant(float a, float c, float h){
    return pow(h, 2) - a * c;
}

// Returns the quadratic formula given a simplified sphere equation
float simplifiedQuadFormula(float a, float h, float discriminant, float signValue){
    return (h + signValue * sqrt(discriminant)) / a; 
}

// Find the sphere's normal vector (not always made to point against the ray [this will be done in hit record])
vec3 findSphereNormalVector(inout HitRecord record, Sphere sphere){
    record.normalVector = (record.pointHit - sphere.center.xyz) / sphere.radius;
    return record.normalVector;
}

// Check if the ray intersects with the sphere using the quadratic formula with math gotten from https://www.cs.colostate.edu/~cs410/yr2016fa/more_progress/cs410_F16_Lecture14.pdf. Automatically deal with returning the lesser t by taking the negative sign first. 
bool checkSphereIntersection(float a, float h, float discriminant, Ray ray, inout HitRecord record){
    float t = simplifiedQuadFormula(a, h, discriminant, -1);
    if (outOfBounds(record.tValues, t)){
        t = simplifiedQuadFormula(a, h, discriminant, 1);
        if (outOfBounds(record.tValues, t)){
            return false; 
        } 
    }

    record.tValues.t = t; 
    record.pointHit = rayIntersectPoint(ray, t);
    return true;
}

// Return the sphere's texture coordinates using math from https://en.wikipedia.org/wiki/UV_mapping
vec2 sphereUV(vec3 outVec){
    float u = 0.5 + atan(outVec.z, outVec.x) / (2 * PI);
    float v = 0.5 + asin(outVec.y) / PI;
    return vec2(u, v);
}

// Do all of the complete logic to check if a ray intersects with a sphere, including finding the discriminant and other values. The difference between this and checkSphereIntersection is that a, h, discriminant are calculated
bool hitSphere(Sphere sphere, Ray ray, inout HitRecord record, inout uvec4 state){
    vec3 rayToSphereCenter = sphere.center.xyz - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float h = dot(ray.direction, rayToSphereCenter);
    float c = dot(rayToSphereCenter, rayToSphereCenter) - pow(sphere.radius, 2);
    float discriminant = simplifiedDiscriminant(a, c, h);

    if (discriminant < 0){ // If the discriminant is less than zero, the t values for the intersection are imaginary and does doesn't intersect (don't even check the t for intersection for efficiency's sake)
        return false;
    }

    bool didHit = checkSphereIntersection(a, h, discriminant, ray, record);
    if (!didHit){
        return false;
    }

    // Note that the ideas for the hit record and storing the intersection points and variables like this came from https://raytracing.github.io/books/RayTracingInOneWeekend.html#movingcameracodeintoitsownclass. Heavily modified though :).
    vec3 outwardNormalVector = findSphereNormalVector(record, sphere);
    isFrontFace(ray, record);
    scatter(sphere.materialID, sphere.materialParameter, ray, record, state);

    record.objectColor = applyTexture(sphere.color.rgb, sphere.textureID, sphereUV(outwardNormalVector));
    
    return true;
}
