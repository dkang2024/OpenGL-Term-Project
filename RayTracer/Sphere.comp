// Sphere Structure
struct sphere3{
    vec3 center;
    float radius;
    vec4 color;
    int materialID;
    float materialParameter;
    vec2 padding;
};

// Sphere ray intersection helper functions 

// Returns the discriminant given a simplified sphere equation
float simplifiedDiscriminant(float a, float c, float h){
    return pow(h, 2) - a * c;
}

// Returns the quadratic formula given a simplified sphere equation
float simplifiedQuadFormula(float a, float h, float discriminant, float signValue){
    return (h + signValue * pow(discriminant, 0.5)) / a; 
}

// Find the sphere's normal vector (not always made to point against the ray [this will be done in hit record])
vec3 findSphereNormalVector(ray3 ray, float t, vec3 center, float radius){
    return (rayIntersectPoint(ray, t) - center) / radius;
}

// Check if the ray intersects with the sphere using the quadratic formula with math gotten from https://www.cs.colostate.edu/~cs410/yr2016fa/more_progress/cs410_F16_Lecture14.pdf. Automaticall deal with returning the lesser t by taking the negative sign first. 
bool checkSphereIntersection(float a, float h, float discriminant, inout hitRecord record){
    float t = simplifiedQuadFormula(a, h, discriminant, -1);
    if (outOfBounds(record.tValues, t)){
        t = simplifiedQuadFormula(a, h, discriminant, 1);
        if (outOfBounds(record.tValues, t)){
            return false; 
        } 
    }

    record.tValues.t = t; 
    return true;
}

// Do all of the complete logic to check if a ray intersects with a sphere, including finding the discriminant and other values. The difference between this and checkSphereIntersection is that a, h, discriminant are calculated
bool hitSphere(sphere3 sphere, inout hitRecord record, inout uvec4 state){
    ray3 ray = record.initRay;
    vec3 rayToSphereCenter = sphere.center - ray.origin;
    float a = dot(ray.direction, ray.direction);
    float h = dot(ray.direction, rayToSphereCenter);
    float c = dot(rayToSphereCenter, rayToSphereCenter) - pow(sphere.radius, 2);
    float discriminant = simplifiedDiscriminant(a, c, h);

    if (discriminant < 0){ // If the discriminant is less than zero, the t values for the intersection are imaginary and does doesn't intersect (don't even check the t for intersection for efficiency's sake)
        return false;
    }

    bool didHit = checkSphereIntersection(a, h, discriminant, record);
    if (!didHit){
        return false;
    }

    // Note that the ideas for the hit record and storing the intersection points and variables like this came from https://raytracing.github.io/books/RayTracingInOneWeekend.html#movingcameracodeintoitsownclass. Heavily modified though :).
    scatter(sphere.materialID, rayIntersectPoint(ray, record.tValues.t), record, state);
    record.normalVector = findSphereNormalVector(ray, record.tValues.t, sphere.center, sphere.radius);
    isFrontFace(record, ray);
    record.rayColor *= sphere.color;
    return true;
}
