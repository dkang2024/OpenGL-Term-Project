const int emptyVoxel = 0;

// Convert a map position to an OpenGL 3D image position (note that the x and z coordinates are swapped [I found this out in a nasty way after I was pulling my hair out])
ivec3 convertToImagePos(ivec3 pos){
    return ivec3(pos.z, pos.y, pos.x);
}

// Check whether a map position is within the world
bool inWorld(ivec3 mapPos){
    ivec3 worldSize = imageSize(world);
    return all(greaterThanEqual(mapPos, ivec3(0))) && all(lessThan(convertToImagePos(mapPos), worldSize));
}

// Get the direction vector for cube texture map sampling 
vec3 cubeDirection(vec3 hitPoint, ivec3 mapPos){
    vec3 centerCube = vec3(mapPos) + vec3(0.5);
    return hitPoint - centerCube;
}

// Determine whether we're inside the voxel for the ray tracing 
void voxelFrontFace(inout HitRecord record, Ray ray, ivec3 mapPos) {
    // Calculate the voxel center
    vec3 voxelCenter = vec3(mapPos) + vec3(0.5);
    record.frontFace = distance(ray.origin, voxelCenter) > 0.5;
}

// DDA Step forward
void ddaStep(inout vec3 mask, inout vec3 sideDist, inout ivec3 mapPos, vec3 deltaDist, ivec3 rayStep){
    mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));

    sideDist += mask * deltaDist;
    mapPos += ivec3(mask) * rayStep;
}

// Set common record values in ray marching 
void setCommonRecordValues(inout HitRecord record, vec3 rayDirSign, vec3 mask, ivec3 mapPos, Ray ray, Material material, inout uvec4 state){
    record.normalVector = -rayDirSign * mask;
    record.tValues.t = dot(record.normalVector, vec3(mapPos) + max(vec3(0), record.normalVector) - ray.origin) / dot(record.normalVector, ray.direction);

    record.pointHit = rayIntersectPoint(ray, record.tValues.t);    
    scatter(material.materialID, material.materialParameter, ray, record, state);     
}

// Set record values in ray marching
void setRecordValues(inout HitRecord record, vec3 rayDirSign, vec3 mask, ivec3 mapPos, Ray ray, Material material, inout uvec4 state){
    setCommonRecordValues(record, rayDirSign, mask, mapPos, ray, material, state);
    voxelFrontFace(record, ray, mapPos);
    record.objectColor = applyTexture(material.color, material.textureID, cubeDirection(record.pointHit, mapPos));   
}

// Extract important information from the voxel world space given the map position 
bool extractVoxel(ivec3 mapPos, inout Material material){
    if (!inWorld(mapPos)){
        return false;
    }

    uint voxelData = imageLoad(world, convertToImagePos(mapPos)).x;
    if (voxelData == emptyVoxel){
        return false;
    }

    uint materialIndex = voxelData - 1;
    if (materialIndex >= 0 && materialIndex < materials.length()){ // Check whether this materialIndex actually exists
        material = materials[materialIndex];
    } 

    return true; 
}

// Branchless DDA with help from https://www.shadertoy.com/view/4dX3zl and https://www.shadertoy.com/view/mtyfRV (I know how branched DDA works, but this is more efficient)
bool rayMarch(Ray ray, inout HitRecord record, inout uvec4 state){
    clampRay(ray);
    
    vec3 invRayDir = 1 / ray.direction;
    vec3 rayDirSign = sign(ray.direction);
    vec3 deltaDist = abs(vec3(length(ray.direction)) * invRayDir);
    ivec3 rayStep = ivec3(rayDirSign);
    
    ivec3 mapPos = ivec3(floor(ray.origin));       
    vec3 sideDist = (rayDirSign * (vec3(mapPos) - ray.origin) + (rayDirSign * 0.5 + 0.5)) * deltaDist;
    
    vec3 mask; Material material = initDefaultMaterial(); Material prevMaterial = initDefaultMaterial(); 

    for (int i = 0; i < maxRaySteps; i++){
        if (!extractVoxel(mapPos, material)){ // If the voxel isn't filled, continue raymarching
            ddaStep(mask, sideDist, mapPos, deltaDist, rayStep);
            continue;
        }
        
        setRecordValues(record, rayDirSign, mask, mapPos, ray, material, state);
        if (material.materialID != DIELECTRIC){// If we can't refract, don't continue raymarching
            return true; 
        }

        Material prevMaterial = material; record.frontFace = !record.frontFace; // If we can refract, raymarch unitl we get out of the dielectric
        
        for (int j = 0; j < maxRaySteps; j++){ // Raymarch until we get out of the dielectric
            ddaStep(mask, sideDist, mapPos, deltaDist, rayStep);
            
            bool voxelExists = extractVoxel(mapPos, material);
            
            if (!(voxelExists && material.materialID == DIELECTRIC && material.materialParameter == prevMaterial.materialParameter)){
                setCommonRecordValues(record, rayDirSign, mask, mapPos, ray, prevMaterial, state);
                return true;
            } 
        } 
    } 
    return false;
}