// Quad Struct. Idea for quads from https://raytracing.github.io/books/RayTracingTheNextWeek.html 
struct Quad{
    vec4 point;
    vec4 side1;
    vec4 side2;
    vec4 color;
    vec4 normalVector;
    vec4 W;
    float D; 
    int materialID;
    float materialParameter;
    int textureID;
};

// Inspired by the function from https://raytracing.github.io/books/RayTracingTheNextWeek.html#quadrilaterals/orientingpointsontheplane
bool isExterior(float alpha, float beta){
    if (outsideUnitInterval(alpha) || outsideUnitInterval(beta)){
        return true;
    }
    return false;
}

// Ray-plane intersection with equations derived from 259 and with some math assistance from https://raytracing.github.io/books/RayTracingTheNextWeek.html 
bool hitQuad(Quad quad, Ray ray, inout HitRecord record, inout uvec4 state){
    vec3 normalVector = quad.normalVector.xyz;
    float denominator = dot(normalVector, ray.direction);
    float epsilon = 1e-8;
    
    if (abs(denominator) < epsilon){
        return false; // No hit for nearly parallel rays
    }
    
    float t = (quad.D - dot(ray.origin, normalVector)) / denominator;
    if (outOfBounds(record.tValues, t)){
        return false;
    }

    vec3 hitPoint = rayIntersectPoint(ray, t);
    vec3 hitVector = hitPoint - quad.point.xyz;
    float alpha = dot(quad.W.xyz, cross(hitVector, quad.side2.xyz));
    float beta = dot(quad.W.xyz, cross(quad.side1.xyz, hitVector));

    if (isExterior(alpha, beta)){
        return false;
    }

    record.tValues.t = t; 
    record.pointHit = hitPoint;
    record.normalVector = normalVector;
    isFrontFace(ray, record);
    scatter(quad.materialID, quad.materialParameter, ray, record, state);

    record.objectColor = applyTexture(quad.color.rgb, quad.textureID, vec2(alpha, beta));

    return true;
}