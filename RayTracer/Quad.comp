// Quad Struct. Idea for quads from https://raytracing.github.io/books/RayTracingTheNextWeek.html 
struct Quad{
    vec3 point;
    float area;
    vec3 side1;
    float D; 
    vec3 side2;
    int materialID;
    vec3 color;
    float materialParameter;
    vec3 normalVector;
    int textureID;
    vec3 W;
    float padding;
};

// Inspired by the function from https://raytracing.github.io/books/RayTracingTheNextWeek.html#quadrilaterals/orientingpointsontheplane
bool isExterior(float alpha, float beta){
    if (outsideUnitInterval(alpha) || outsideUnitInterval(beta)){
        return true;
    }
    return false;
}

// Ray-plane intersection with equations derived from 259 and with some math assistance from https://raytracing.github.io/books/RayTracingTheNextWeek.html 
bool hitQuad(Quad quad, Ray ray, inout HitRecord record, inout uvec4 state){
    vec3 normalVector = quad.normalVector;
    float denominator = dot(normalVector, ray.direction);
    float epsilon = 1e-8;
    
    if (abs(denominator) < epsilon){
        return false; // No hit for nearly parallel rays
    }
    
    float t = (quad.D - dot(ray.origin, normalVector)) / denominator;
    if (outOfBounds(record.tValues, t)){
        return false;
    }

    vec3 hitPoint = rayIntersectPoint(ray, t);
    vec3 hitVector = hitPoint - quad.point;
    float alpha = dot(quad.W, cross(hitVector, quad.side2));
    float beta = dot(quad.W, cross(quad.side1, hitVector));

    if (isExterior(alpha, beta)){
        return false;
    }

    record.tValues.t = t; 
    record.pointHit = hitPoint;
    record.normalVector = normalVector;
    isFrontFace(ray, record);
    scatter(quad.materialID, quad.materialParameter, ray, record, state);

    record.objectColor = applyTexture(quad.color, quad.textureID, vec2(alpha, beta));

    return true;
}

// Sample a random point on the quad for light sampling
vec3 randomOnQuad(Quad quad, inout uvec4 state){
    return quad.point + rand(state) * quad.side1 + rand(state) * quad.side2;
}

// Quad Light PDF (given by the modified rendering equation for directly sampling lights)
float quadLightPDF(Quad quad, HitRecord record, inout float lightTime, inout Ray lightRay, inout uvec4 state){
    vec3 toLight = randomOnQuad(quad, state) - record.pointHit;
    float distanceSquared = dot(toLight, toLight);

    vec3 normalizedToLight = normalize(toLight);
    float cosLight = abs(dot(normalizedToLight, quad.normalVector));
    lightRay = Ray(record.pointHit, normalizedToLight);
    lightTime = toLight.x / normalizedToLight.x;

    return distanceSquared / (cosLight * quad.area);
}