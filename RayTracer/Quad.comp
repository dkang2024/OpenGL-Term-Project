// Quad Struct. Idea for quads from https://raytracing.github.io/books/RayTracingTheNextWeek.html 
struct Quad{
    vec3 point;
    float area;
    vec3 side1;
    float D; 
    vec3 side2;
    int materialID;
    vec3 color;
    float materialParameter;
    vec3 normalVector;
    int textureID;
    vec3 W;
    float padding;
};

// Inspired by the function from https://raytracing.github.io/books/RayTracingTheNextWeek.html#quadrilaterals/orientingpointsontheplane
bool isExterior(float alpha, float beta){
    if (outsideUnitInterval(alpha) || outsideUnitInterval(beta)){
        return true;
    }
    return false;
}

// Common quad intersection code in both hitQuad and hitQuadLight
bool commonQuadCalculations(Quad quad, Ray ray, Interval tInterval, inout float t, inout vec3 hitPoint, inout vec3 normalVector, inout float alpha, inout float beta){
    normalVector = quad.normalVector;
    float denominator = dot(normalVector, ray.direction);
    float epsilon = 1e-8;
    
    if (abs(denominator) < epsilon){
        return false; // No hit for nearly parallel rays
    }
    
    t = (quad.D - dot(ray.origin, normalVector)) / denominator;
    if (outOfBounds(tInterval, t)){
        return false;
    }

    hitPoint = rayIntersectPoint(ray, t);
    vec3 hitVector = hitPoint - quad.point;
    alpha = dot(quad.W, cross(hitVector, quad.side2));
    beta = dot(quad.W, cross(quad.side1, hitVector));

    if (isExterior(alpha, beta)){
        return false;
    }
    return true;
}

// Ray-plane intersection with equations derived from 259 and with some math assistance from https://raytracing.github.io/books/RayTracingTheNextWeek.html 
bool hitQuad(Quad quad, Ray ray, inout HitRecord record, inout uvec4 state){
    float t;
    vec3 hitPoint;
    vec3 normalVector;
    float alpha;
    float beta;

    bool didHit = commonQuadCalculations(quad, ray, record.tValues, t, hitPoint, normalVector, alpha, beta);
    if (!didHit){
        return false;
    }

    record.tValues.t = t; 
    record.pointHit = hitPoint;
    record.normalVector = normalVector;
    scatter(quad.materialID, quad.materialParameter, ray, record, state);

    //record.objectColor = applyTexture(quad.color, quad.textureID, vec3(alpha, beta, 0));

    return true;
}

// Sample a random point on the quad for light sampling
vec3 randomOnQuad(Quad quad, inout uvec4 state){
    return quad.point + rand(state) * quad.side1 + rand(state) * quad.side2;
}

// Quad Light PDF (given by the modified rendering equation for directly sampling lights)
float quadLightPDF(Quad quad, HitRecord record, inout float lightTime, inout Ray lightRay, inout uvec4 state){
    vec3 toLight = randomOnQuad(quad, state) - record.pointHit;
    float distanceSquared = dot(toLight, toLight);

    vec3 normalizedToLight = normalize(toLight);
    float cosLight = abs(dot(normalizedToLight, quad.normalVector));
    lightRay = Ray(record.pointHit, normalizedToLight);
    lightTime = toLight.x / normalizedToLight.x;

    return distanceSquared / (cosLight * quad.area);
}

bool hitQuadLight(Quad quad, Ray ray, Interval tInterval){
    float t;
    vec3 hitPoint;
    vec3 normalVector;
    float alpha;
    float beta;
    return commonQuadCalculations(quad, ray, tInterval, t, hitPoint, normalVector, alpha, beta);
}